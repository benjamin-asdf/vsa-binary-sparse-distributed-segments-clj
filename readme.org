High dimensional computing is a great approach to neuromorphic, neurosymbolic computing.

* Sparse Binary Vectors

Brain networks exhibit sparse pattern activity, which is the motivation to explore high dimensional computing with sparse vectors.
Sparse VSA architectures have been show to have competitive capacity and desirable HDC properties.[fn:1]
At the same time, they have drastically reduced memory consumption.

Blog post:

** HDV/VSA implementation

Following the paper [[https://www.researchgate.net/publication/299535938_High-Dimensional_Computing_with_Sparse_Vectors][High-Dimensional Computing with Sparse Vectors]] [Laiho,Poikonen,Kanerva,Lehtonen 2020].

[[file:src/bennischwerdtner/hd/binary_sparse_segmented.clj][binary_sparse_segmented.clj]] contains an implementation of 'Binary Sparse Distributed Representation with segments' (naming from [[*2]])

** Datastructures / "Programming in Superposition"

Following [[https://arxiv.org/abs/2106.05268][Vector Symbolic Architectures as a Computing Framework for Emerging Hardware]], I made some example
complex datastructures.

[[file:/src/bennischwerdtner/hd/data.clj]]

Sets, Sequences, Stacks, Graphs, Trees, Finite State Automaton.

Perhaps HDC/VSA's most distinguished aspect is '*programing in superposition*'.
The HDC/VSA set is basically a bloom filter, but it is not limited to sets. Via VSA we can represent structured data.

(I highly recommend the literature if you are interested, this is not a tutorial, but exploring a software level perspective on excisting work).

Here, finite state automata are represented as a superpostion of transitions.
One can query with a superposition state, making it a nondeterministic finite-state automaton.
In effect, running all it's possible transitions in parallel.

#+begin_src clojure
  ;; --------------------
  ;; Nondeterministic finite-state automaton
  ;; --------------------
  ;; - it can be in several states at once
  ;; - there can be several valid transitions from a given current state and input symbol
  ;; - It can assume a so-called generalized state,
  ;;   defined as a set of the automaton's states that are simultaneously active
  ;; - a generalized state corresponds to a hypervector representing the set of the currenlty active states
  ;; - query the same way, is like executing the automaton in parallel (in superposition)
  ;; - cleanup will have to search for several nearest neighbors
  ;;

  ;; automaton in superposition (i.e. just query with states that are in superposition)
  ;;

  (def water-domain
    (apply
     finite-state-automaton
     (clj->vsa*
      ;;  transition exressed in symbolic domain
      [[:frozen :heat :liquid] [:liquid :heat :gas]
       [:liquid :cool :frozen] [:gas :cool :liquid]
       [:gas :heat :gas] [:frozen :cool :frozen]])))

  (cleanup*
   (automaton-destination water-domain
                          (hd/superposition
                           (clj->vsa :liquid)
                           (clj->vsa :frozen))
                          (clj->vsa :cool)))
  '(:frozen)

  ;; if your state is the superposition of liquid and frozen

  (cleanup* (automaton-destination water-domain
                                   (hd/superposition
                                    (clj->vsa :liquid)
                                    (clj->vsa :frozen))
                                   (clj->vsa :heat)))
  '(:liquid :gas)

  ;; I mean, there is something else that is even crazier (or am I missing something?)
  ;; that is this:

  (def water-bender-domain
    (apply finite-state-automaton
           (map #(map clj->vsa %)
                [[:frozen :heat :shards]
                 [:liquid :heat :bubbles]
                 [:liquid :cool :absolute-zero]])))

  ;; now I have 2 automatons,

  (cleanup* (automaton-destination
             ;; ... superimpose them
             (hd/superposition water-domain water-bender-domain)
             (hd/superposition
              (clj->vsa :liquid)
              (clj->vsa :frozen))
             (clj->vsa :heat)))

  '(:liquid :gas :shards :bubbles)

  ;; and we just run them in parallel, lol
  ;; stuff like that.
#+end_src
*** Fun With Trees

[[file:examples/fun_with_trees.clj]] contains a bit of a walk through of some 'programing in superposition' concepts.


** Examples

[[file:./examples][examples]] contains examples and expirements.

*** What Is The Dollar In Mexico?

The implementation succesfully represents the analogy-reasoning example from Kanerva ([[*3]]):

#+begin_src clojure

    (def mexico-record
      (h/thin
       (h/bundle
        (h/bind (symbol->hv :capital) (symbol->hv 'mxc))
        (h/bind (symbol->hv :currency) (symbol->hv 'peso))
        (h/bind (symbol->hv :name) (symbol->hv 'mex)))))

    (def usa-record
      (h/thin (h/bundle (h/bind (symbol->hv :capital)
                                (symbol->hv 'wdc))
                        (h/bind (symbol->hv :currency)
                                (symbol->hv 'dollar))
                        (h/bind (symbol->hv :name)
                                (symbol->hv 'usa)))))


    (let [result
          (h/unbind mexico-record
                    ;; this represents the query
                    (h/unbind usa-record (symbol->hv 'dollar)))]

      (cleanup-lookup-value result))
  ;;  => peso

#+end_src

*** Hyper-If

[[file:./examples/hyper_if.clj]]

#+begin_src clojure

    ;; Idea 1:
    ;;
    ;; A hyper if
    ;; In high dimensional computing, the outcome of a calculation could represent
    ;; the combination of all 'possible' outcomes.
    ;;
    ;; Interesting here to note is that 'what is possible?' is defined by the threshold, too.
    ;;
    ;; We can imagine dynamically lowering and increasing the threshold.
    ;; (Would model something like 'fast' and 'slow' thinking perhaps).
    ;;


  ;; a hyper-if evaluates to the information mix of all 'possible' branches.

  (def both-true-and-false
    (hd/thin
     (hd/bundle
      (->prototype true)
      (->prototype false))))

  (defn coin
    []
    (hyper-if both-true-and-false
              (->prototype :heads)
              (->prototype :tails)))

  ;; all the bookeeping can go away ofc
  (map :k (cleanup-lookup-verbose (coin)))

  ;; => (:heads :tails)

#+end_src

We can envisage a programming paradigm that models something like a multiverse, where multiple things are true.
(This is probably very close to /probabilistic programming/, I know little of that).

Similarly, a =multi-symbol= could resolve to either a list of things, or to a thing representing the set of things.

---

Such explorations are found in

[[file:/examples/sequence_processor.clj]], which I consider 'attic', 'on the shelf'.

But making *some* kind of Lisp interpreter gave me at least training with using hdvs.

* Sparse Distributed Memory


[[file:src/bennischwerdtner/sdm/sdm.clj]] contains a sparse distributed memory implementation using

[[https://github.com/clj-python/libpython-clj][libpythonclj]], numpy + torch.

This was a quick way for me to implement a gpu version, making this reasonably fast.


** Python setup

- Set up a python env, and run clojure using this env.
- I achieve this here with python venv  and the scripts activate.sh, run.sh and dev.el


- requirments:
  pytorch
  numpy

- `python -m venv venv`
- `. ./activate.sh`
- `pip install pytorch numpy`
- start cider via dev.el, or start clojure via run.sh, or tell your tooling to use run.sh as clojure program


* Acknowledgements

Thanks to [[https://github.com/gigasquid/vsa-clj][Carin Meier's intro to VSA]].

Thanks to [[https://github.com/cnuernber/dtype-next][Chris Nuernberger's dtype next]] for high performance and linear algebra stuff at the clojure repl.

* Future

- Dynamic sparsity mechanisms could perhaps represent different /levels of detail/, or parallel search processes[fn:2].
- Develop datastructures, languages, tools, and a software philosophy for [[https://arxiv.org/abs/2106.05268][/Programming in superposition/]].


* Literatrue

[[file:./lit.org]]


* Footnotes

[fn:1]

Schlegel et.al. 2021  A comparison of Vector Symbolic Architectures

http://www.arxiv.org/abs/2001.11797
arXiv:2001.11797

[fn:2]

G. Palm Neural Assemblies: An Alternative Approach to Artificial Intelligence, (first edition: 1982, 2nd ed.: 2022)
